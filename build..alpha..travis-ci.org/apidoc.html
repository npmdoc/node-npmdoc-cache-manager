<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/BryanDonovan/node-cache-manager#readme"

    >cache-manager (v2.4.0)</a>
</h1>
<h4>Cache module for Node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.cache-manager">module cache-manager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.caching">
            function <span class="apidocSignatureSpan">cache-manager.</span>caching
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.callback_filler">
            function <span class="apidocSignatureSpan">cache-manager.</span>callback_filler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.multiCaching">
            function <span class="apidocSignatureSpan">cache-manager.</span>multiCaching
            <span class="apidocSignatureSpan">(caches, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">cache-manager.</span>callback_filler.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.cache-manager.caching">module cache-manager.caching</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.caching.caching">
            function <span class="apidocSignatureSpan">cache-manager.</span>caching
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.cache-manager.callback_filler">module cache-manager.callback_filler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.callback_filler.callback_filler">
            function <span class="apidocSignatureSpan">cache-manager.</span>callback_filler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.cache-manager.callback_filler.prototype">module cache-manager.callback_filler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.callback_filler.prototype.add">
            function <span class="apidocSignatureSpan">cache-manager.callback_filler.prototype.</span>add
            <span class="apidocSignatureSpan">(key, funcObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.callback_filler.prototype.fill">
            function <span class="apidocSignatureSpan">cache-manager.callback_filler.prototype.</span>fill
            <span class="apidocSignatureSpan">(key, err, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.callback_filler.prototype.has">
            function <span class="apidocSignatureSpan">cache-manager.callback_filler.prototype.</span>has
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.cache-manager.multiCaching">module cache-manager.multiCaching</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.cache-manager.multiCaching.multiCaching">
            function <span class="apidocSignatureSpan">cache-manager.</span>multiCaching
            <span class="apidocSignatureSpan">(caches, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.cache-manager" id="apidoc.module.cache-manager">module cache-manager</a></h1>


    <h2>
        <a href="#apidoc.element.cache-manager.caching" id="apidoc.element.cache-manager.caching">
        function <span class="apidocSignatureSpan">cache-manager.</span>caching
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">caching = function (args) {
    args = args || {};
    var self = {};
    if (typeof args.store === &#x27;object&#x27;) {
        if (args.store.create) {
            self.store = args.store.create(args);
        } else {
            self.store = args.store;
        }
    } else {
        var storeName = args.store || &#x27;memory&#x27;;
        self.store = require(&#x27;./stores/&#x27; + storeName).create(args);
    }

    // do we handle a cache error the same as a cache miss?
    self.ignoreCacheErrors = args.ignoreCacheErrors || false;

    var Promise = args.promiseDependency || global.Promise;

    var callbackFiller = new CallbackFiller();

    if (typeof args.isCacheableValue === &#x27;function&#x27;) {
        self._isCacheableValue = args.isCacheableValue;
    } else if (typeof self.store.isCacheableValue === &#x27;function&#x27;) {
        self._isCacheableValue = self.store.isCacheableValue;
    } else {
        self._isCacheableValue = function(value) {
            return value !== undefined;
        };
    }

    function wrapPromise(key, promise, options) {
        return new Promise(function(resolve, reject) {
            self.wrap(key, function(cb) {
                Promise.resolve()
                .then(promise)
                .then(function(result) {
                    cb(null, result);
                })
                .catch(cb);
            }, options, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

<span class="apidocCodeCommentSpan">    /**
     * Wraps a function in cache. I.e., the first time the function is run,
     * its results are stored in cache so subsequent calls retrieve from cache
     * instead of calling the function.
     *
     * @function
     * @name wrap
     *
     * @param {string} key - The cache key to use in cache operations
     * @param {function} work - The function to wrap
     * @param {object} [options] - options passed to `set` function
     * @param {function} cb
     *
     * @example
     *   var key = &#x27;user_&#x27; + userId;
     *   cache.wrap(key, function(cb) {
     *       User.get(userId, cb);
     *   }, function(err, user) {
     *       console.log(user);
     *   });
     */
</span>    self.wrap = function(key, work, options, cb) {
        if (typeof options === &#x27;function&#x27;) {
            cb = options;
            options = {};
        }

        if (!cb) {
            return wrapPromise(key, work, options);
        }

        var hasKey = callbackFiller.has(key);
        callbackFiller.add(key, {cb: cb});
        if (hasKey) { return; }

        self.store.get(key, options, function(err, result) {
            if (err &#x26;&#x26; (!self.ignoreCacheErrors)) {
                callbackFiller.fill(key, err);
            } else if (self._isCacheableValue(result)) {
                callbackFiller.fill(key, null, result);
            } else {
                work(function(err, data) {
                    if (err) {
                        callbackFiller.fill(key, err);
                        return;
                    }

                    if (!self._isCacheableValue(data)) {
                        callbackFiller.fill(key, null, data);
                        return;
                    }

                    if (options &#x26;&#x26; typeof options.ttl === &#x27;function&#x27;) {
                        options.ttl = options.ttl(data);
                    }

                    self.store.set(key, data, options, function(err) {
                        if (err &#x26;&#x26; (!self.ignoreCacheErrors)) {
                            callbackFiller.fill(key, err);
                        } else {
                            callbackFiller.fill(key, null, data);
                        }
                    });
                });
            }
        });
    };

    /**
     * Binds to the underlying store&#x27;s `get` function.
     * @function
     * @name get
     */
    self.get = self.store.get.bind(self.store);

    /**
     * Binds to the underlying store&#x27;s `set` function.
     * @function
     * @name set
     */
    self.set = self.store.set.bind(self.store);

    /** ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
See examples below and in the examples directory.  See ``examples/redis_example`` for an example of how to implement a
Redis cache store with connection pooling.

### Single Store

```javascript
var cacheManager = require(&#x27;cache-manager&#x27;);
var memoryCache = cacheManager.<span class="apidocCodeKeywordSpan">caching</span>({store: &#x27;memory&#x27;, max: 100, ttl: 10/*
seconds*/});
var ttl = 5;
// Note: callback is optional in set() and del().

memoryCache.set(&#x27;foo&#x27;, &#x27;bar&#x27;, {ttl: ttl}, function(err) {
if (err) { throw err; }

memoryCache.get(&#x27;foo&#x27;, function(err, result) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.cache-manager.callback_filler" id="apidoc.element.cache-manager.callback_filler">
        function <span class="apidocSignatureSpan">cache-manager.</span>callback_filler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CallbackFiller() {
    this.queues = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.cache-manager.multiCaching" id="apidoc.element.cache-manager.multiCaching">
        function <span class="apidocSignatureSpan">cache-manager.</span>multiCaching
        <span class="apidocSignatureSpan">(caches, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiCaching = function (caches, options) {
    var self = {};
    options = options || {};

    var Promise = options.promiseDependency || global.Promise;

    if (!Array.isArray(caches)) {
        throw new Error(&#x27;multiCaching requires an array of caches&#x27;);
    }

    var callbackFiller = new CallbackFiller();

    if (typeof options.isCacheableValue === &#x27;function&#x27;) {
        self._isCacheableValue = options.isCacheableValue;
    } else {
        self._isCacheableValue = function(value) {
            return value !== undefined;
        };
    }

<span class="apidocCodeCommentSpan">    /**
     * If the underlying cache specifies its own isCacheableValue function (such
     * as how node-cache-manager-redis does), use that function, otherwise use
     * self._isCacheableValue function.
     */
</span>    function getIsCacheableValueFunction(cache) {
        if (cache.store &#x26;&#x26; typeof cache.store.isCacheableValue === &#x27;function&#x27;) {
            return cache.store.isCacheableValue;
        } else {
            return self._isCacheableValue;
        }
    }

    function getFromHighestPriorityCachePromise(key, options) {
        return new Promise(function(resolve, reject) {
            getFromHighestPriorityCache(key, options, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

    function getFromHighestPriorityCache(key, options, cb) {
        if (typeof options === &#x27;function&#x27;) {
            cb = options;
            options = {};
        }

        if (!cb) {
            return getFromHighestPriorityCachePromise(key, options);
        }

        var i = 0;
        async.eachSeries(caches, function(cache, next) {
            var callback = function(err, result) {
                if (err) {
                    return next(err);
                }

                var _isCacheableValue = getIsCacheableValueFunction(cache);

                if (_isCacheableValue(result)) {
                    // break out of async loop.
                    return cb(err, result, i);
                }

                i += 1;
                next();
            };

            cache.store.get(key, options, callback);
        }, function(err, result) {
            return cb(err, result);
        });
    }

    function setInMultipleCachesPromise(caches, opts) {
        return new Promise(function(resolve, reject) {
            setInMultipleCaches(caches, opts, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

    function setInMultipleCaches(caches, opts, cb) {
        opts.options = opts.options || {};

        if (!cb) {
            return setInMultipleCachesPromise(caches, opts);
        }

        async.each(caches, function(cache, next) {
            var _isCacheableValue = getIsCacheableValueFunction(cache);

            if (_isCacheableValue(opts.value)) {
                cache.store.set(opts.key, opts.value, opts.options, next);
            } else {
                next();
            }
        }, function(err, result) {
            cb(err, result);
        });
    }

    function getAndPassUpPromise(key) {
        return new Promise(function(resolve, reject) {
            self.getAndPassUp(key, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

    /**
     * Looks for an item in cache tiers.
     * When a key is found in a lower cache, all higher levels are updated.
     *
     * @param {string} key
     * @param {function} cb
     */
    self.getAndPassUp = function(key, cb) {
        if (!cb) {
            return getAndPassUpPromise(key);
        }

        getFromHighestPriorityCache(key, function(err, result, index) {
            if (err) {
                return cb(err);
            }

            if (index) {
                var cachesToUpdate = caches.slice(0, index);
                async.each(cachesToUpdate, func ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var myStore = require(&#x27;your-homemade-store&#x27;);
var cache = cacheManager.caching({store: myStore});
```

### Multi-Store

```javascript
var multiCache = cacheManager.<span class="apidocCodeKeywordSpan">multiCaching</span>([memoryCache, someOtherCache]);
userId2 = 456;
key2 = &#x27;user_&#x27; + userId;
ttl = 5;

// Sets in all caches.
multiCache.set(&#x27;foo2&#x27;, &#x27;bar2&#x27;, {ttl: ttl}, function(err) {
if (err) { throw err; }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.cache-manager.caching" id="apidoc.module.cache-manager.caching">module cache-manager.caching</a></h1>


    <h2>
        <a href="#apidoc.element.cache-manager.caching.caching" id="apidoc.element.cache-manager.caching.caching">
        function <span class="apidocSignatureSpan">cache-manager.</span>caching
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">caching = function (args) {
    args = args || {};
    var self = {};
    if (typeof args.store === &#x27;object&#x27;) {
        if (args.store.create) {
            self.store = args.store.create(args);
        } else {
            self.store = args.store;
        }
    } else {
        var storeName = args.store || &#x27;memory&#x27;;
        self.store = require(&#x27;./stores/&#x27; + storeName).create(args);
    }

    // do we handle a cache error the same as a cache miss?
    self.ignoreCacheErrors = args.ignoreCacheErrors || false;

    var Promise = args.promiseDependency || global.Promise;

    var callbackFiller = new CallbackFiller();

    if (typeof args.isCacheableValue === &#x27;function&#x27;) {
        self._isCacheableValue = args.isCacheableValue;
    } else if (typeof self.store.isCacheableValue === &#x27;function&#x27;) {
        self._isCacheableValue = self.store.isCacheableValue;
    } else {
        self._isCacheableValue = function(value) {
            return value !== undefined;
        };
    }

    function wrapPromise(key, promise, options) {
        return new Promise(function(resolve, reject) {
            self.wrap(key, function(cb) {
                Promise.resolve()
                .then(promise)
                .then(function(result) {
                    cb(null, result);
                })
                .catch(cb);
            }, options, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

<span class="apidocCodeCommentSpan">    /**
     * Wraps a function in cache. I.e., the first time the function is run,
     * its results are stored in cache so subsequent calls retrieve from cache
     * instead of calling the function.
     *
     * @function
     * @name wrap
     *
     * @param {string} key - The cache key to use in cache operations
     * @param {function} work - The function to wrap
     * @param {object} [options] - options passed to `set` function
     * @param {function} cb
     *
     * @example
     *   var key = &#x27;user_&#x27; + userId;
     *   cache.wrap(key, function(cb) {
     *       User.get(userId, cb);
     *   }, function(err, user) {
     *       console.log(user);
     *   });
     */
</span>    self.wrap = function(key, work, options, cb) {
        if (typeof options === &#x27;function&#x27;) {
            cb = options;
            options = {};
        }

        if (!cb) {
            return wrapPromise(key, work, options);
        }

        var hasKey = callbackFiller.has(key);
        callbackFiller.add(key, {cb: cb});
        if (hasKey) { return; }

        self.store.get(key, options, function(err, result) {
            if (err &#x26;&#x26; (!self.ignoreCacheErrors)) {
                callbackFiller.fill(key, err);
            } else if (self._isCacheableValue(result)) {
                callbackFiller.fill(key, null, result);
            } else {
                work(function(err, data) {
                    if (err) {
                        callbackFiller.fill(key, err);
                        return;
                    }

                    if (!self._isCacheableValue(data)) {
                        callbackFiller.fill(key, null, data);
                        return;
                    }

                    if (options &#x26;&#x26; typeof options.ttl === &#x27;function&#x27;) {
                        options.ttl = options.ttl(data);
                    }

                    self.store.set(key, data, options, function(err) {
                        if (err &#x26;&#x26; (!self.ignoreCacheErrors)) {
                            callbackFiller.fill(key, err);
                        } else {
                            callbackFiller.fill(key, null, data);
                        }
                    });
                });
            }
        });
    };

    /**
     * Binds to the underlying store&#x27;s `get` function.
     * @function
     * @name get
     */
    self.get = self.store.get.bind(self.store);

    /**
     * Binds to the underlying store&#x27;s `set` function.
     * @function
     * @name set
     */
    self.set = self.store.set.bind(self.store);

    /** ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
See examples below and in the examples directory.  See ``examples/redis_example`` for an example of how to implement a
Redis cache store with connection pooling.

### Single Store

```javascript
var cacheManager = require(&#x27;cache-manager&#x27;);
var memoryCache = cacheManager.<span class="apidocCodeKeywordSpan">caching</span>({store: &#x27;memory&#x27;, max: 100, ttl: 10/*
seconds*/});
var ttl = 5;
// Note: callback is optional in set() and del().

memoryCache.set(&#x27;foo&#x27;, &#x27;bar&#x27;, {ttl: ttl}, function(err) {
if (err) { throw err; }

memoryCache.get(&#x27;foo&#x27;, function(err, result) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.cache-manager.callback_filler" id="apidoc.module.cache-manager.callback_filler">module cache-manager.callback_filler</a></h1>


    <h2>
        <a href="#apidoc.element.cache-manager.callback_filler.callback_filler" id="apidoc.element.cache-manager.callback_filler.callback_filler">
        function <span class="apidocSignatureSpan">cache-manager.</span>callback_filler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CallbackFiller() {
    this.queues = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.cache-manager.callback_filler.prototype" id="apidoc.module.cache-manager.callback_filler.prototype">module cache-manager.callback_filler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.cache-manager.callback_filler.prototype.add" id="apidoc.element.cache-manager.callback_filler.prototype.add">
        function <span class="apidocSignatureSpan">cache-manager.callback_filler.prototype.</span>add
        <span class="apidocSignatureSpan">(key, funcObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (key, funcObj) {
    if (this.queues[key]) {
        this.queues[key].push(funcObj);
    } else {
        this.queues[key] = [funcObj];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.cache-manager.callback_filler.prototype.fill" id="apidoc.element.cache-manager.callback_filler.prototype.fill">
        function <span class="apidocSignatureSpan">cache-manager.callback_filler.prototype.</span>fill
        <span class="apidocSignatureSpan">(key, err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fill = function (key, err, data) {
    var waiting = this.queues[key];
    delete this.queues[key];

    if (waiting &#x26;&#x26; waiting.length) {
        waiting.forEach(function(task) {
            (task.cb)(err, data);
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.cache-manager.callback_filler.prototype.has" id="apidoc.element.cache-manager.callback_filler.prototype.has">
        function <span class="apidocSignatureSpan">cache-manager.callback_filler.prototype.</span>has
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (key) {
    return this.queues[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.cache-manager.multiCaching" id="apidoc.module.cache-manager.multiCaching">module cache-manager.multiCaching</a></h1>


    <h2>
        <a href="#apidoc.element.cache-manager.multiCaching.multiCaching" id="apidoc.element.cache-manager.multiCaching.multiCaching">
        function <span class="apidocSignatureSpan">cache-manager.</span>multiCaching
        <span class="apidocSignatureSpan">(caches, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiCaching = function (caches, options) {
    var self = {};
    options = options || {};

    var Promise = options.promiseDependency || global.Promise;

    if (!Array.isArray(caches)) {
        throw new Error(&#x27;multiCaching requires an array of caches&#x27;);
    }

    var callbackFiller = new CallbackFiller();

    if (typeof options.isCacheableValue === &#x27;function&#x27;) {
        self._isCacheableValue = options.isCacheableValue;
    } else {
        self._isCacheableValue = function(value) {
            return value !== undefined;
        };
    }

<span class="apidocCodeCommentSpan">    /**
     * If the underlying cache specifies its own isCacheableValue function (such
     * as how node-cache-manager-redis does), use that function, otherwise use
     * self._isCacheableValue function.
     */
</span>    function getIsCacheableValueFunction(cache) {
        if (cache.store &#x26;&#x26; typeof cache.store.isCacheableValue === &#x27;function&#x27;) {
            return cache.store.isCacheableValue;
        } else {
            return self._isCacheableValue;
        }
    }

    function getFromHighestPriorityCachePromise(key, options) {
        return new Promise(function(resolve, reject) {
            getFromHighestPriorityCache(key, options, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

    function getFromHighestPriorityCache(key, options, cb) {
        if (typeof options === &#x27;function&#x27;) {
            cb = options;
            options = {};
        }

        if (!cb) {
            return getFromHighestPriorityCachePromise(key, options);
        }

        var i = 0;
        async.eachSeries(caches, function(cache, next) {
            var callback = function(err, result) {
                if (err) {
                    return next(err);
                }

                var _isCacheableValue = getIsCacheableValueFunction(cache);

                if (_isCacheableValue(result)) {
                    // break out of async loop.
                    return cb(err, result, i);
                }

                i += 1;
                next();
            };

            cache.store.get(key, options, callback);
        }, function(err, result) {
            return cb(err, result);
        });
    }

    function setInMultipleCachesPromise(caches, opts) {
        return new Promise(function(resolve, reject) {
            setInMultipleCaches(caches, opts, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

    function setInMultipleCaches(caches, opts, cb) {
        opts.options = opts.options || {};

        if (!cb) {
            return setInMultipleCachesPromise(caches, opts);
        }

        async.each(caches, function(cache, next) {
            var _isCacheableValue = getIsCacheableValueFunction(cache);

            if (_isCacheableValue(opts.value)) {
                cache.store.set(opts.key, opts.value, opts.options, next);
            } else {
                next();
            }
        }, function(err, result) {
            cb(err, result);
        });
    }

    function getAndPassUpPromise(key) {
        return new Promise(function(resolve, reject) {
            self.getAndPassUp(key, function(err, result) {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }

    /**
     * Looks for an item in cache tiers.
     * When a key is found in a lower cache, all higher levels are updated.
     *
     * @param {string} key
     * @param {function} cb
     */
    self.getAndPassUp = function(key, cb) {
        if (!cb) {
            return getAndPassUpPromise(key);
        }

        getFromHighestPriorityCache(key, function(err, result, index) {
            if (err) {
                return cb(err);
            }

            if (index) {
                var cachesToUpdate = caches.slice(0, index);
                async.each(cachesToUpdate, func ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var myStore = require(&#x27;your-homemade-store&#x27;);
var cache = cacheManager.caching({store: myStore});
```

### Multi-Store

```javascript
var multiCache = cacheManager.<span class="apidocCodeKeywordSpan">multiCaching</span>([memoryCache, someOtherCache]);
userId2 = 456;
key2 = &#x27;user_&#x27; + userId;
ttl = 5;

// Sets in all caches.
multiCache.set(&#x27;foo2&#x27;, &#x27;bar2&#x27;, {ttl: ttl}, function(err) {
if (err) { throw err; }
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
